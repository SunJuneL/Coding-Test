# [BOJ 1966 - 프린터 큐(Swift)](https://www.acmicpc.net/problem/1966)

### 기본 전제<br/>
 - 현재 큐에서 가장 앞에 있는 문서의 중요도보다 다른 문서들 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 큐의 가장 뒤에 재배치한다. 만약 그렇지 않다면 바로 인쇄한다.<br/>
 - 어떤 문서가 몇 번째로 인쇄되는지 알아내야 한다.<br/>
 - 테스트 케이스의 개수의 범위는 적혀있지 않다.<br/>
 - 문서의 개수 `N`의 범위는 1 이상 100 이하이다.<br/>
 - 몇 번째로 인쇄되는지 궁금한 문서가 몇 번째에 놓어있는지 나타내는 정수 `M`의 범위는 0 이상 N 미만이다.<br/>
<br/>

### 주의 사항<br/>
 - 없음.<br/>
<br/>

### 전략<br/>
 - 조건에 쓰여있는 대로, 맨 앞에 문서와 다른 문서의 중요도를 비교해 가장 큰 값이 있으면 뒤로 재배치한다. 그리고, 중요도 최대값이 맨 앞에 있다면 인쇄한다.<br/>
 - 이를 반복해서 찾으려는 문서의 중요도가 배열 전체의 중요도 최대값과 같다면, 그때 이후로는 찾는 문서가 인쇄될 때까지 중요도가 같은 문서만 인쇄한다.<br/>
<br/>

---
### 본문<br/>

1. 테스트케이스의 개수를 입력 받고, 테스트케이스 개수만큼 반복한다.<br/>
```Swift
// 테스트케이스 개수를 입력 받음
let T = Int(readLine() ?? "1") ?? 1

// 테스트케이스 개수만큼 반복함
for _ in 1 ... T {
    ・
    ・
    ・
}
```
 - `T`: 테스트케이스의 개수를 저장하는 상수.<br/>
 <br/>

2. N과 M 그리고 각 문서의 중요도를 입력 받는다.<br/>
```Swift
// 문서의 개수 N과 몇 번쨰로 인쇄되는지 궁금한 문서 M을 입력 받음
let input = (readLine() ?? "1 0").components(separatedBy: " ")
let N = Int(input[0]) ?? 1
let M = Int(input[1]) ?? 0

// 중요도를 입력 받음
let importances = (readLine() ?? "1").components(separatedBy: " ").map{ Int($0) ?? 1 }
```
 - `N`: 문서의 개수를 저장하는 상수.<br/>
 - `M`: 찾는 문서의 인덱스를 저장하는 상수.<br/>
 - `importances`: 각 문서의 중요도를 저장하는 정수형 배열.<br/>
 <br/>

3. 문서 재배치 및 인쇄를 위해 사용할 변수들을 선언한다.<br/>
```Swift
// 중요도 배열을 사용하기 위해 선언한 임시 배열
var arr = importances
// 현재 중요도 배열에서의 최대값
var max = arr.max() ?? 1
// 인쇄된 문서의 개수
var count = 0
// arr배열에서 찾는 문서의 index
var m = M
```
 - `arr`: 인쇄 및 재배치에 활용할 각 문서의 중요도를 저장한 배열.<br/>
 - `max`: `arr`배열에 저장된 중요도 중 최대값을 저장할 변수.<br/>
 - `count`: 인쇄된 문서의 개수를 저장할 변수.<br/>
 - `m`: `arr`배열에서 찾는 문서의 인덱스를 저장한 변수.<br/>
<br/>

4. 전체 문서들의 중요도 최대값이 찾는 문서의 중요도와 같을 때까지 재배치 및 인쇄한다.<br/>
```Swift
// 현재 중요도 배열에서의 최대값이 찾으려는 문서의 중요도보다 크면 반복함
while importances[M] < max {
    // 현재 배열에서 가장 첫번째 값이 최대값이 아니라면 맨 뒤로 보냄
    if arr[0] != max {
        arr.append(arr.removeFirst())
    // 현재 배열에서 가장 첫번째 값을 제거한 이후 배열의 최대값을 변경
    } else {
        arr.removeFirst()
        max = arr.max() ?? 1
        count += 1
    }
    
    // 찾는 문서의 인덱스를 현재 배열에 맞게 설정
    m -= 1
    if m < 0 {
        m += arr.count
    }
}
```
 - 전체 문서의 최대 중요도가 찾는 문서의 중요도보다 크면, 아래의 내용을 실행한다.<br/>
    - 가장 첫 번째 문서의 중요도가 `max`보다 작으면 맨 뒤로 보낸다.<br/>
    - 가장 첫 번째 문서의 중요도가 `max`와 같다면 인쇄한다.<br/>
        - 인쇄하면 `count`를 하나 늘리고, 큐에 남아있는 문서들로 `max`를 다시 구한다.<br/>
    - 인쇄가 됐든, 재배치가 됐든 찾는 문서의 위치가 바뀌었기 때문에 `m`을 변경한다.<br/>
 - 이를 반복해 찾는 문서의 중요도가 전체 문서의 최대 중요도인 배열을 구한다.<br/>
<br/>

4. 이전 작업을 통해 얻은 배열 `arr`과 `m`을 이용해서 몇 번째에 인쇄되었는지 구한다.<br/>
```Swift
// 현재 배열에서 찾는 문서가 몇 번째로 출력되는지 확인
for i in 0 ... m {
    if arr[i] == importances[M] {
        count += 1
    }
}
```
 - 구한 `arr` 배열의 0 번째 문서에서 `m` 번째 문서까지 확인하여, 각 문서의 중요도가 찾는 문서의 중요도와 같다면 `count`를 증가시킨다.<br/>
<br/>

---
### 문제를 맨 처음에 틀렸던 이유<br/>
- 없음.<br/>
<br/>

---
### 느낀점<br/>
- 없음.<br/>
<br/>

--- 
### 푸는데 참고한 참고 자료<br/>
- 없음.<br/>
<br/>

---
### 시험한 테스트 케이스
<br/>

테스트 케이스 1<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        3
        1 0
        5
        4 2
        1 2 3 4
        6 0
        1 1 9 1 1 1
        ```
    - 출력
        ```Swift
        1
        2
        5
        ```
<br/>
