# [BOJ 2108 - 통계학(Swift)](https://www.acmicpc.net/problem/2108)

### 기본 전제<br/>
 - 입력되는 숫자의 개수 `N`은 홀수이다.<br/>
 - 네 가지 통계값을 구한다.<br/>
    - 산술 평균: `N`개의 수들의 합을 `N`으로 나눈 값이다.<br/>
        - 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.<br/>
    - 중앙값: `N`개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값이다.<br/>
    - 최빈값: `N`개의 수들 중 가장 많이 나타나는 값이다.<br/>
        - 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.<br/>
    - 범위: `N`개의 수들 중 최댓값과 최솟값의 차이이다.<br/>
<br/>

### 주의 사항<br/>
 - 없음.<br/>
<br/>

### 전략<br/>
 - 배열과 딕셔너리를 선언해, 두 컬렉션에 `N`개의 숫자들을 모두 넣는다.<br/>
 - 이후 배열을 정렬하고, 정렬된 배열을 이용해 중앙값과 범위, 산술 평균을 구한다.<br/>
 - 딕셔너리를 이용해 최빈값을 구한다.<br/>
<br/>

---
### 본문<br/>

1. `N`을 입력 받고, 통계값을 구하기 위한 배열, 딕셔너리, 산술평균에 사용할 변수를 선언한다.<br/>
```Swift
// N을 입력 받음 (1 이상 500000 이하)
let N = Int(readLine() ?? "1") ?? 1

// 숫자들을 저장할 딕셔너리
var dict: [Int: Int] = [:]
// 숫자들을 저장할 배열
var arr: [Int] = []
// 산술평균
var aver = 0.0
```
 - `N`: 숫자의 개수. 1 이상 500000 이하의 홀수이다.<br/>
 - `dict`: 숫자들을 저장할 딕셔너리. (key: 숫자 값, value: 해당 숫자의 개수)로 이루어져 있다.<br/>
 - `arr`: 숫자들을 저장할 배열.<br/>
 - `aver`: 산술평균을 구하기 위해 선언한 Double 타입 변수.<br/>
 <br/>

2. 숫자들을 입력 받아 배열과 딕셔너리에 저장하고 `aver` 변수에 각 숫자들을 더한다.<br/>
```Swift
// 숫자들을 입력받아 배열, 딕셔너리에 저장
for _ in 1 ... N {
    let num = Int(readLine() ?? "0") ?? 0
    arr.append(num)
    dict[num] = (dict[num] ?? 0) + 1
    aver += Double(num)
}
```
 - `num`: 입력 받은 숫자.<br/>
 - `num`을 arr에 append()한다.<br/>
 - `num`이 `dict`에 `key`값으로 있다면 `value`값을 1 올리고, `key`값으로 없다면 `value`값으로 1을 저장한다.<br/>
 - `aver`에 `num`을 더한다.<br/>
 <br/>

3. 산술평균을 구한다.<br/>
```Swift
// 산술평균 구하기
aver /= Double(N)
let average = Int(aver.rounded())
```
 - 숫자들을 입력 받을 때, `aver`값에 `N`개의 숫자들을 모두 더했으므로 `aver`값을 `N`으로 나눈 뒤 반올림을 이용해 [산술평균]을 구한다.<br/>
<br/>

4. 중앙값을 구한다.<br/>
```Swift
// 중앙값 구하기
arr.sort()
let middle = arr[N / 2]
```
 - `arr`배열을 오름차순으로 정렬한다.<br/>
 - `N`은 홀수이므로, 정중앙에 있는 값의 index는 `N / 2`이다.<br/>
<br/>

5. 최빈값을 구한다.<br/>
```Swift
// 최빈값 구하기
var maxCount = dict.values.max() ?? 0
var maximums: [Int] = []
for e in dict {
    if e.value == maxCount {
        maximums.append(e.key)
    }
}
maximums.sort()
var max = 0
if 1 < maximums.count {
    max = maximums[1]
} else {
    max = maximums[0]
}
```
 - `maxCount`: `dict`에서 `value`가 가장 큰 값.<br/>
 - `maximums`: `dict`에서 `value`가 `maxCount`와 같은 `key`값 들을 저장하는 배열.<br/>
    - `value`값이 `maxCount`와 같은 `key`값들이 여러 개 있을 수 있기 때문에 배열로 선언한다.<br/>
 - `max`: 최빈값을 저장할 변수.<br/>
    - `maximums` 배열을 오름차순으로 정렬한다.<br/>
    - 개수가 1개 이하라면 가장 처음 값을 저장한다.<br/>
    - 개수가 1개 초과라면, 앞에서 두 번째에 있는 값을 저장한다.<br/> 
<br/>

6. 범위를 구한다.<br/>
```Swift
// 범위 구하기
let range = arr[N - 1] - arr[0]
```
 - **중앙값 구하기**에서 이미 `arr`를 정렬했기 때문에 가장 마지막 값과 처음 값의 차이를 구해 저장한다.<br/>
<br/>

---
### 문제를 맨 처음에 틀렸던 이유<br/>
- 없음.<br/>
<br/>

---
### 느낀점<br/>
- 없음.<br/>
<br/>

---
### 새로 알게된 내용<br/>
- 없음.<br/> 
<br/>

--- 
### 푸는데 참고한 참고 자료<br/>
- 없음.<br/>
<br/>

---
### 시험한 테스트 케이스
<br/>

테스트 케이스 1<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        5
        1
        3
        8
        -2
        2
        ```
    - 출력
        ```Swift
        2
        2
        1
        10
        ```
<br/>

테스트 케이스 2<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        1
        4000
        ```
    - 출력
        ```Swift
        4000
        4000
        4000
        0
        ```
<br/>

테스트 케이스 3<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        5
        -1
        -2
        -3
        -1
        -2
        ```
    - 출력
        ```Swift
        -2
        -2
        -1
        2
        ```
<br/>

테스트 케이스 4<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        3
        0
        0
        -1
        ```
    - 출력
        ```Swift
        0
        0
        0
        1
        ```
<br/>
