# [BOJ 4948 - 베르트랑 공준(Swift)](https://www.acmicpc.net/problem/4948)

### 기본 전제<br/>
- 자연수 `n`을 입력 받는다.<br/>
    - `n`은 1보다 크거나 같고, 123,456보다 작거나 같다.<br/>
- 입력된 자연수 `n`에 대하여, `n`보다 크고, `2n`보다 작거나 같은 소수의 개수를 구한다.<br/>
<br/>

### 주의 사항<br/>
- 없음.<br/>
<br/>

### 전략<br/>
- 자연수 `n`의 범위가 1 이상 123456 이하이기 때문에, 구해야하는 소수의 범위가 `2 × 123456`으로 정해져 있다.<br/>
    - 따라서, 0부터 `2 × 123456`까지 범위 내에서 소수를 "에라토스테네스의 체"를 이용해 구한다.<br/>
    - "에라토스테네스의 체"로 거르는 건, 0부터 `√(123456 * 2) = 496.9024049046` 까지면 된다.<br/>
    - "에라토스테네스의 체"로 거를 때, 특정 수가 소수라면 그 수의 배수를 거르면 된다.<br/>
- `n` 초과 `2n` 이하의 소수의 개수를 구한다.<br/>
<br/>

---
### 본문<br/>

1. `n`에 따른 소수를 확인할 최대 범위와 소수를 저장할 배열을 선언한다.<br/>
```Swift
// 소수를 확인할 범위의 최대값 선언
let limit = 2 * 123456

// 소수를 저장하는 배열
var isPrime = [false, false] + Array(repeating: true, count: limit - 1)
```
- `limit`: 소수를 확인할 범위의 최대 값을 저장하는 상수이다.<br/>
    - `2n`까지 확인해야 하므로, `2 * 123456`의 값을 갖는다.<br/>
- `isPrime`: 해당 인덱스의 수가 소수인지 아닌지를 저장하는 불리언 타입의 배열이다.<br/>
    - 인덱스가 3인 경우, `isPrime[3]`의 값은 `true`이다.<br/>
    - "에라토스테네스의 체"를 통해 소수인지 아닌지를 파악해 이 배열을 수정한다. 따라서 `var`을 이용해 선언한다.<br/>
    - 0과 1은 소수가 아니므로, 선언할 때 앞부분에 `[false, false]`를 추가한다.<br/>
<br/>

2. `isPrime` 배열을 알맞게 수정한다.<br/>
```Swift
// 에라토스테네스의 체를 이용해 소수인지 아닌지 거름
for i in 0...Int(sqrt(Double(limit))) {
    // i가 소수라면, i를 제외한 i의 배수들은 모두 소수가 아님
    if isPrime[i] {
        for j in stride(from: (2 * i), through: limit, by: i) {
            isPrime[j] = false
        }
    }
}
```
- 에라토스테네스의 체를 이용해 소수인지 아닌지 걸러 `isPrime` 배열을 수정한다.<br/>
    - 1부터 `√limit` 까지 범위의 소수들의 배수를 거른다.<br/> 
        - 만약, 1부터 `n`까지 범위 내의 소수들을 구한다고 한다면, 1부터 `√n`까지 범위의 소수들의 배수들을 거르면 된다.<br/>
    - 따라서 i가 소수라면, i를 제외한 i의 배수들을 전체 범위에서 거른다.<br/>
<br/>

3. 자연수 n을 입력 받고, 출력값을 출력한다. 그리고 이를 반복한다.<br/>
```Swift
// 0을 입력 받을 때까지 반복
while true {
    // 자연수 n 입력 받음
    let n = Int(readLine() ?? "1") ?? 1
    
    // n이 0이면 반복문 정지
    if n == 0 {
        break
    }
    
    // n보다 크고, 2n보다 작거나 같은 소수의 개수 출력
    print(isPrime[(n + 1) ... (2 * n)].filter{ $0 }.count)
}
```
- `n`: 입력 받은 자연수 n을 저장하는 상수이다.<br/>
- `n`으로 0이 입력될 때까지 반복문을 반복한다.<br/>
    - 0이 입력되면 반복문을 멈춘다.<br/>
- `isPrime` 배열에서 인덱스의 범위가 `n + 1` 이상 `2 * n`인 값들을 모아, `true`값들의 개수를 구해 출력한다.<br/>
<br/>

---
### 문제를 맨 처음에 틀렸던 이유<br/>
- 없음.<br/>
<br/>

---
### 느낀점<br/>
- "에라토스테네스의 체"를 바로 떠올리고 활용할 수 있었어서 조금의 성장을 느꼈다.<br/>
- `stride(from: , to: , by: )`, `stride(from: , through: , by: )`라는 편한 것을 알게 되어 좋았다.<br/>
    - 앞으로 이를 잘 활용하면 좋겠다.<br/>
<br/>

---
### 참고 사항<br/>
- 2번 "에라토스테네스의 체"를 활용해 `isPrime` 배열을 수정하는 부분에서 코드를 변경했다.<br/>
    - 원래 아래와 같은 코드를 작성했다.<br/>
    ```Swift
    // 에라토스테네스의 체를 이용해 소수인지 아닌지 거름
    for i in 0...Int(sqrt(Double(limit))) {
        // i가 소수라면, i를 제외한 i의 배수들은 모두 소수가 아`님
        if isPrime[i] {
            for j in (i + 1) ... maxN {
                if j % i == 0 {
                    eratosthenes[j] = false
                }
            }
        }
    }
    ```
    - 위 코드의 문제점은 `i`가 소수일 경우, `i + 1` 이상 `maxN` 이하 범위를 반복하고, 이 코드가 대략 497번 반복된다는 것이다.<br/>
        - `√(123456 * 2) = 496.9024049046`이기 때문에 대략 497번 반복한다.<br/>
    - 따라서 아래의 코드와 같이 stride()를 활용해 변경하였다.<br/>
    ```Swift
    // 에라토스테네스의 체를 이용해 소수인지 아닌지 거름
    for i in 0...Int(sqrt(Double(limit))) {
        // i가 소수라면, i를 제외한 i의 배수들은 모두 소수가 아`님
        if isPrime[i] {
            for j in stride(from: (2 * i), through: limit, by: i) {
                isPrime[j] = false
            }
        }
    }
    ```
    - 위 처럼 바뀌어 `i`의 배수만큼만 특정 코드를 반복해 시간을 굉장히 효과적으로 단축시킬 수 있었다.<br/>
        - 기존 코드의 시간은 100ms였는데, 변경된 코드의 시간은 20ms으로 큰 효과를 얻을 수 있었다.<br/>
    
- `stride(from: , to: , by: )`와 `stride(from: , through: , by: )`의 차이를 알아야 한다.<br/>
    - `stride(from: x, to: y, by: 1)`의 경우, `(x..<y)`를 나타낸다.<br/>
        - 즉, `x` 이상 `y` 미만을 나타낸다.<br/>
    - `stride(from: x, through: y, by: 1)`의 경우, `(x...y)`를 나타낸다.<br/>
        - 즉, `x` 이상 `y` 이하를 나타낸다.<br/>
    - 이러한 차이로 `stride(from: , to: , by: )`를 사용하면, 문제 해결에 실패하거나 `to:` 부분체 `maxN + 1`을 적어야 한다.<br/>

- 범위 내 소수의 개수를 구하는 방법으로 `SubArray`, `filter()`와 `.count`를 활용한다.<br/> 
    - 문제 해결을 한 사람들 중, 0부터 `i`까지 범위 내의 소수의 개수를 저장하는 배열 `primesCount[i]`를 만드는 사람들이 꽤 있었다.<br/>
        - 따라서 `n` 초과 `2n` 이하 범위의 소수의 개수는 `primeCount[2 * n] - primeCount[n]`을 통해 구한다.<br/>
    - 위와 같은 방법을 사용해 보았는데, 메모리를 꽤나 차지하는데 비해 시간이 획기적으로 줄지 않고, 똑같이 20ms가 걸렸다.<br/>
    - 이러한 이유로 배열을 선언하지 않고, 현재 사용하는 방법으로 문제를 해결하였다.<br/>

<br/>

---
### 새로 알게된 내용<br/>
- `stride(from: x, to: y, by: z)`<br/>
    - `x`부터 시작하여, `z`만큼의 보폭으로 `y` 미만의 수까지의 값들을 `StrideTo<Type>`의 타입으로 리턴해준다.<br/>
    ```Swift
    print([Int](stride(from: 0, to: 100, by: 5)))
    print(stride(from: 0, to: 100, by: 5))
    ```
    - 위 코드를 이용해 아래의 결과를 얻을 수 있다.<br/>
    ```Swift
    [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
    Swift.StrideTo<Swift.Int>
    ```
    - 0부터 시작하기 때문에 0이 포함되어 있으며, 5의 보폭을 갖기 때문에 5의 배수로 나열되어 있다. 또한, 100 미만의 범위이기 때문에 100이 제외되어 있다.<br/>
    - `Int` 타입들이기 때문에 `stride(from: , to: , by: )`의 결과로 `StrideTo<Swift.Int>`가 나온다.<br/>
        - `StrideTo<Swift.Int>`는 `Range`로서 `for문`에서 활용할 수 있다.<br/>

    
- `stride(from: x, through: y, by: z)`<br/>
    - `x`부터 시작하여, `z`만큼의 보폭으로 `y` 이하의 수까지의 값들을 `StrideThrough<Type>`의 타입으로 리턴해준다.<br/>
    ```Swift
    print([Int](stride(from: 0, through: 100, by: 5)))
    print(stride(from: 0, through: 100, by: 5))
    ```
    - 위 코드를 이용해 아래의 결과를 얻을 수 있다.<br/>
    ```Swift
    [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]
    Swift.StrideThrough<Swift.Int>
    ```
    - 0부터 시작하기 때문에 0이 포함되어 있으며, 5의 보폭을 갖기 때문에 5의 배수로 나열되어 있다. 또한, 100 이하의 범위이기 때문에 100이 포함되어 있다.<br/>
    - `Int` 타입들이기 때문에 `stride(from: , through: , by: )`의 결과로 `StrideThrough<Swift.Int>`가 나온다.<br/>
        - `StrideThrough<Swift.Int>`는 `Range`로서 `for문`에서 활용할 수 있다.<br/>
<br/>

--- 
### 푸는데 참고한 참고 자료<br/>
- [whqtkf12님의 풀이](https://www.acmicpc.net/source/36912784)<br/>
- [김종권님의 블로그 (for, stride, Range)](https://ios-development.tistory.com/361)<br/>
<br/>

---
### 시험한 테스트 케이스
<br/>

테스트 케이스 1<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        1
        10
        13
        100
        1000
        10000
        100000
        0
        ```
    - 출력
        ```Swift
        1
        4
        3
        21
        135
        1033
        8392
        ```
<br/>
