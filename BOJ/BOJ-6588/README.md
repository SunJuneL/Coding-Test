# [BOJ 6588 - 골드바흐의 추측(Swift/C++)](https://www.acmicpc.net/problem/6588)

### 기본 전제<br/>
 - 6보다 크거나 같은 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.<br/>
     - 즉, `n`을 이루는 두 홀수가 소수인지 확인하면 된다.<br/>
<br/>

### 주의 사항<br/>
 - 참고자료에도 나와있지만, 제한 시간이 굉장히 짧기 때문에 일반적으로 사용하는 방법 (특정 수 `n`이 입력될 때 마다 1부터 `n`까지 나누어 보아 약수가 2개 뿐인지 확인하는 방법)을 사용하면 무.조.건. 시간초과가 생긴다.<br/>
    - 특정 범위의 소수들을 구하는 방법 중 가장 빠르다고 알려진 방법이 바로 "에라토스테네스의 체" 방법이다.<br/>
 - 소수는 약수의 개수가 2개 (자기 자신과 1)인 수 이므로, 1부터 `n`의 제곱근까지만 확인하면 된다.<br/>
    - 제곱근까지 확인했을 때 약수의 개수가 1개 뿐이라면, `n`은 한 쌍의 약수의 곱으로만 표현할 수 있다는 의미이며, 이는 `n`이 소수라는 뜻이다.<br/>
<br/>

---
### 본문<br/>

1. 기본적으로 사용할 변수 및 배열을 선언한다.<br/>
```Swift
// n의 최대값
let maxN = 1000001

// 소수인지 판별할 배열
var isPrimeNumber = Array(repeating: true, count: maxN)
```
 - `maxN`: n의 최대값 (0을 포함하는 배열이어야 하므로 최대에서 1을 더한 1000001으로 설정한다.)<br/>
 - `isPrimeNumber`: 소수인지 판별할 배열 (`index`가 소수라면 `true`, 소수가 아니라면 `false`의 값을 갖도록 한다.)<br/>
    - 이렇게 해야 특정 수가 소수인지 아닌지 바로 확인할 수 있다. (시간을 줄이기 위해 사용)
 <br/>

2. "에라토스테네스의 체" 개념을 사용해 `isPrimeNumber`를 설정하는 함수를 선언한다.<br/>
- "에라토스테네스의 체"의 자세한 설명은 [위키백과](https://ko.wikipedia.org/wiki/에라토스테네스의_체) 혹은 [나무위키](https://namu.wiki/w/에라토스테네스의%20체)를 참고하면 좋다.<br/>
- 간단하게 설명하자면, 2부터 `n`까지의 수들을 `n` 제곱근보다 작은 소수들의 배수들을 체에 거르듯 제거하면 `n`보다 작은 소수들을 구할 수 있다는 것이 "에라토스테네스의 체"이다.<br/>
```Swift
// 에라토스테네스의 체를 이용해 소수들을 구하는 함수
func eratosthenes() {
        // 0과 1은 소수가 아님
    isPrimeNumber[0] = false
    isPrimeNumber[1] = false
    
    // 2부터 제한된 값 까지 확인하며 소수의 배수를 거름 (에라토스테네스의 체)
    var i = 2
    while (i * i < maxN) {
        if isPrimeNumber[i] == true {
            var j = 2
            while (i * j < maxN) {
                isPrimeNumber[i * j] = false
                j += 1
            }
        }
        i += 1
    }
}
```
 - 0과 1은 소수가 아니므로 해당 `index`의 `isPrimeNumber` 값을 `false`로 바꾼다.<br/>
 - 2 부터 `n`까지의 수 `i`를 확인한다.
    - `i`가 소수라면, `index`가 `n`보다 작은 모든 `i`의 배수인 `isPrimeNumber` 값을 `false`로 바꾼다.<br/>
    - 이때 `i`는 소수이므로 `i`의 배수에서 자기자신은 제외해야 한다.<br/>
<br/>

3. 골드바흐의 추측에 따라 n을 두 홀수 소수의 합으로 나타낸다.<br/>
``` Swift
// 골드바흐의 추측을 구하는 함수
func goldbach(_ n: Int) -> String {
    // n의 절반
    let limit = n / 2
    
    // 3부터 limit까지 확인하여, 골드바흐의 추측이 맞다면 표현식 String 리턴
    for i in stride(from: 3, through: limit, by: 2) {
        let j = n - i
        if isPrimeNumber[i] && isPrimeNumber[j] {
            return "\(n) = \(i) + \(j)"
        }
    }
    
    // 골드바흐의 추측이 틀렸다면 틀렸다는 내용의 String 리턴
    return "Goldbach's conjecture is wrong."
}
```
 - `n`을 두 홀수의 합으로 나타내기 때문에, 한 수를 3부터 `n`의 절반까지 확인하면 된다.<br/>
    - 그래서 `n / 2`를 `limit`이라는 상수에 저장하고 사용한다. 
 - 두 홀수 중에서 크기가 작은 값을 `i`라고 한다.<br/>
    - `i`를 기준으로 두 홀수가 소수인지 확인할 것이고, 따라서 `i`의 범위가 3부터 `limit`이다.
    - "홀수" 이므로 `i`의 값을 2씩 증가시켜 확인한다. 
 - 두 홀수 중에서 크기가 큰 값을 `j`라고 한다.<br/>
    - 따라서 `j`의 값은 `n - i`이다.<br/>
 - `i`와 `j`가 소수인지 확인하여, 둘 다 소수라면 바로 `"n = i + j"`를 리턴한다.<br/>
    - 만약 `"n = i + j"`을 만족하는 소수 `i`와 `j`가 없다면, `"Goldbach's conjecture is wrong."`를 리턴한다.
<br/>

---
### 문제를 맨 처음에 틀렸던 이유<br/>
- 주의사항에 써 놓은 것처럼 "에라토스테네스의 체"를 사용하지 않고, 하나하나 소수인지 확인했기 때문이었다.<br/>
<br/>

---
### 느낀점<br/>
- "에라토스테네스의 체"를 알고 있는지 물어보는 문제 같았다.<br/>
    - "소수"에 관련된 문제의 경우 꽤나 유용하게 사용할 수 있다는 생각이 들어, 꼭 기억하는 것이 좋아보인다.<br/>
<br/>

---
### 시험한 테스트 케이스
<br/>

테스트 케이스 1<br/>
- 기본적으로 백준에 써 있는 테스트 케이스이다.<br/>
    - 입력
        ```Swift
        8
        20
        42
        0
        ```
    - 출력
        ```Swift
        8 = 3 + 5
        20 = 3 + 17
        42 = 5 + 37
        ```
<br/>

--- 
푸는데 참고한 참고 자료: https://korean-otter.tistory.com/51<br/>
<br/>
